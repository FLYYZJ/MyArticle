## 全排列
全排列即是找到一组数或者字符的所有可能的排序，例如 123 的全排列为  
  123 132 213 231 312 321
找到全排列的算法可以用回溯算法实现，如下图所示
![](images/20181226175738.jpg)  
因此可以用递归的方式实现上图中的树结构，代码如下（求连续n个不相同数的全排列）：

```python
class Solution:
    def getPermutation(self, n):
        """
        :type n: 求n个数的全排列
        :rtype: 全排列结果，一个list
        """
        L = [str(i) for i in range(1, n + 1)]
        result = []
        self.permutation(L, '', result)
        return result # 得到的result即为全排列的结果

    def permutation(self, L, r_str, result):
        if len(L) == 1:
            result.append(r_str + L[0])
            return
        for i in range(len(L)):
            self.permutation(L[0:i] + L[i + 1:], r_str + L[i], result)

```
假如我们要求n个数的全排列中的第k个数（[leetcode-60](https://leetcode-cn.com/problems/permutation-sequence/)），显然是不能直接求全排列然后再求其中第k个值的（超时错误），此时需要利用一些技巧，此时我们可以通过k的大小确定第k个全排列数的每个位置上的值（总共有n个位置），从而只需要遍历 n 次（每次遍历中会计算一次比n小的数的阶乘）就可以算出第k个全排列数的值，从而提高整个算法的效率。具体思路为：

以\[1,2,3,4\]的全排列为例，找第14个排列

- 以1开头的排列总共有3!个，原因是第一个位置是1，剩下3个位置可以随便排列，有6个
- 以2开头的排列总共有3!个，原因是第一个位置是2，剩下3个位置可以随便排列，有6个
- 此时已经有12个排列,所以剩下的两个排列即第14个排列一定在以3开头的排列中  

用这种方式继续缩减数量，以3开头的排列中最小的为\[3,1,2,4\]，3已经固定，那么就找\[1,2,4\]的全排列的第2个排列，就是整个排列的第14个排列

- 以1开头的排列共有2!个，原因是第二个位置是1，剩下2个位置可以随便排列，有2个  
- 此时已经有两个排列，可以确定结果一定在以\[3,1\]开头的排列中，即\[3,1,2,4\]或\[3,1,4,2\]  

继续缩减数量，以\[3,1\]开头的排列中最下的为\[3,1,2,4\]，\[3,1\]已经固定，那么就找\[2,4\]的全排列的第2个排列，就是\[1,2,4\]的全排列的第2个排列，也就是整个排列的第14个排列

- 以2开头的排列共有1!个，原因是第三个位置是2，剩下一个位置给4，有1个
- 以4开头的排列共有1!个，原因是第三个位置是4，剩下一个位置给12，有1个

此时已经有两个排列，可以确定结果是以4开头的排列，即\[4,2\]，所以结果为\[3,1,4,2\]


整体算法流程为
根据数组的索引规则，索引从0开始，此时k为14，即要找第13个排列（从0开始，因此k要减1）， 下面的流程中， **i从1开始递增的，直到n**  
第一步，序列为\[1,2,3,4\]，k为13，i为1，(n-i)!为6，k / (n-i)!为2，k / (n-i)!为2，即第2个数字（从0开始），为3  
第二步，序列为\[1,2,4\]，确定以3开头后，k为1，i为2，(n-i)!为2，k / (n-i)!为0，即第0个数字，为1  
第三步，序列为\[2,4\]，确定以1开头后，k为1，i为3，(n-i)!为1，k / (n-i)!为1，即第1个数字，为4  
返回 3142

具体代码如下：
```python
class Solution:
    def getPermutation(self, n, k):
        """
        :type n: int
        :type k: int
        :rtype: str
        """
        result = ''
        k = k-1
        L = [str(i) for i in range(1,n+1)]
        for i in range(1,n+1): 
            if len(L) == 1:
                return result+L[0]
            n_i_ = self.caln(n-i)
            r = int(k / n_i_)
            result += L[r]
            L.remove(L[r])
            k -= n_i_ * r
    def caln(self,n):
        r = 1
        if n == 0:
            return 1
        for i in range(1,n+1):
            r *= i
        return r

```

## 参考：
https://blog.csdn.net/sinat_35261315/article/details/78412805


## 子集合
思路： 例如求 \[1,2,3\]的子集合，这个时候我们可以想到其实可以先求3的子集合，即{ {}, {3} }，而 \[2,3\]的子集合其实就是3的子集合、3的子集合的所有子集加入2，以此类推可得结果。算法的基本思路就是从小集合逐步拼凑成大集合，且中间不会有多余的计算。而实现中一开始求后面的数值的子集合时不加空集{}，在求1的子集合的时候再添加空集{}，这样便于代码编写。
```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        # 很pythonic的解法
        res = [[]]
        for i in nums:
            res = res + [[i] + num for num in res]
        return res
# 我的解法
#         if len(nums) < 1:
#             return [[]]
#         result = [[],[nums[0]]]
#         if len(nums) == 1:
#             return result
#         for res in self._subset(nums[1:]):
#             result.append(res)
#             res = list(res)
#             res.insert(0, nums[0])
#             result.append(res)
#         return result
        
    
#     def _subset(self, nums):
#         
#         if len(nums) == 1:
#             return [[nums[0]]]
#         result = [[nums[0]]]
#         for res in self._subset(nums[1:]):
#             result.append(res)
#             res = list(res)
#             res.insert(0, nums[0])
#             result.append(res)
#         return result
```
