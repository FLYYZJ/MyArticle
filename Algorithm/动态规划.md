## 动态规划（Dynamic Programming）简介
一种设计的技巧，是解决多阶段决策过程最优化问题的通用方法。

基本思想：将待求解问题**分解成若干个子问题**，先求解子问题，然后从这些子问题的解得到原问题的解（这部分与分治法相似）。与分治法不同的是，适合于用动态规划求解的问题，经分解得到的子问题往往不是互相独立的。若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们**能够保存已解决的子问题的答案，而在需要时再找出已求得的答案**，这样就可以避免大量的重复计算，节省时间。通常可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划的基本思路

规划算法的核心是记住已经求过的解，记住求解的方式有两种：1、自顶向下的备忘录法 2、自底向上

可采用动态规划算法求解的问题具有 ：
1. **最优子结构**：问题的一个最优解中所包含的子问题的解也是最优的
2. **重叠子问题**：用递归算法对问题进行求解时，每次产生的子问题并不总是新问题，有些子问题会被重复计算多次。

因此动态规划的关键点在于 —— 基于备忘录以空间换时间，从较小的问题开始逐步决策求解同时不重复求解子问题，进而解决原始问题。

## 几道题理解动态规划算法：
(leetcode 198 - 打家劫舍)[https://leetcode-cn.com/problems/house-robber/description/]

针对这道题，首先我们来看下是否有最有子结构，上面说了，我们一般需要用一个备忘录来记录已经解答的子问题的答案，一般备忘录是一个一维或二维数组。而数组中的元素一般和要解答的问题的答案是相关的，一般我们可以定义为问题所要求的答案。假设此时有一个数组c,此时c\[n]表示针对第n个家庭所能得到的最高金额，此时我们知道有如下两种选择，偷窃或不偷窃，假设盗窃第n个家庭可获益nums\[n]，此时可获益有如下三种可能：

c\[n-1](注意只能隔一家大家，不然会触发警报) 和 c\[n-2] + nums\[n] 和 c\[n-3] + nums\[n]，那为什么不算c\[n-4] + nums\[n]，因为c\[n-4] + nums\[n] < c\[n-4] + nums\[n-2] + nums\[n] <= c\[n-2] + nums\[n]，因此往前的情况也是如此，因此可以不再考虑，所以我们发现问题是具有最优子结构的，即
```math
c[n] = max(c[n-1],c[n-2]+nums[n],c[n-3]+nums[n])
```
所以根据上面的递推表达式，可得到上述问题的解如下：
```python
class Solution:
    def rob(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        if len(nums) == 0:
            return 0
        elif len(nums) == 1:
            return nums[0]
        elif len(nums) == 2:
            return max(nums[0],nums[1])
        elif len(nums) == 3:
            return max(nums[0] + nums[2],nums[1])
        else:
            c = [0] * len(nums)
            c[0] = nums[0]
            c[1] = max(nums[0],nums[1])
            for i in range(2,len(nums)):
                c[i] = c[i-1] if c[i-1] > c[i-2] + nums[i] else c[i-2] + nums[i]
                c[i] = c[i] if c[i] > c[i-3] + nums[i] else c[i-3] + nums[i]
        return c[len(nums)-1]
```

