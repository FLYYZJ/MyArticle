## 一切皆对象

### python中的函数和类都是对象，属于python的一等公民。
1. 可赋值给变量
2. 可以加入集合中
3. 可以作为函数的返回值
4. 可作为参数传递给函数
```python
# 函数是对象
def ask(name='yzj_func'):
    print(name)
myfunc = ask # 1. 可以赋值给变量
myfunc()
# 类是对象
class Person:
    def __init__(self):
        print('yzj_class')
myclass = Person
myclass()
# 可以加入集合中
objlist = [Person,ask]
for obj in objlist:
    print(obj())
# 作为函数的返回值
def decorator_func():
    print('des start')
    return ask
myask = decorator_func()
myask('hello world')
```
### type,object和class的关系
1. type（类，也是一个对象，继承于object，是type的实例） - 返回一个对象的类型，或者用于生成一个类（我们构建的类都是由type这个类生成的）。
2. object 是所有类继承的一个基类(最顶层基类，默认继承，是type的实例，没有基类)，查看一个类的基类的方法是 classname.\_\_bases\_\_

![](https://github.com/undersunshine/MyArticle/blob/master/Algorithm/images/201810181024.png)

### python中常见的内置类型
1. 对象的三个特征—— 对象的id（利用id(obj)方法可以查看）,对象均有一个类型，对象都有一个值。
常见类型：
```python
None: 全局中仅有一个，唯一一个的对象
数值类型： bool，数值int和float，complex复数类型
迭代类型：可以用for循环进行遍历
序列类型：list，bytes，range，tuple....
映射类型：dict
集合：set，frozenset
上下文管理类型：可以用with语句进行访问
其它....
```


## 魔法函数
在类中以双下划线开头的一些python内置方法，例如__init__，__getitem__等

__str__方法和__repr__方法：
```python
class Company:
    def __init__(self,employee_list):
        self.emplyee = employee_list
    
    def __str__(self): # 用于字符串格式化
        return ','.join(self.emplyee) # print方法打印对象时输出的文本信息

    def __repr__(self): # 在开发模式下调用,直接键入对象名会打印返回文本信息
        return ','.join(self.emplyee)

company = Company(['tom','bob','jack'])
print(company) # 输出 tom,bob,jack
```

## 类和对象深入

### 鸭子类型
几个类提供了相同的方法，执行相似的操作，则这几个类可以归为同一个类型（因此python才分为迭代类型，序列类型等等，在python中称为数据类型）。鸭子类型也是这个概念。然后在一些操作中，例如list的extend方法，其要求传入的类型为可迭代类型，例如a，b，c都是可迭代类型，则都可传入。而静态语言需要具体到特定的类型，例如只能传入a类，b类或c类，这样python的灵活性比较高。而鸭子类型是基于python的魔法函数（通过设置魔法函数以实现不同的特性）实现的。

### 抽象基类 —— abc模块
抽象基类不能实例化，抽象基类的应用场景是在某些情况下需要判断某个对象的类型，或者强制某些子类必须实现某些方法
```python
hasattr(o,attrname); # 判断某个对象是否有某个属性（方法或属性变量） 
isinstance(o,classtype); # 判断某个对象是否是某个类型

import abc
class CacheBase(metaclass=abc.ABCMeta):
    @abc.abstractmethod # 定义为抽象方法，则子类必须实现该方法才能被初始化，否则子类初始化会报错
    def hello(self,k):
        pass
# 等价于
class CacheBase():
    def hello(self,k):
        raise NotImplementedError

# isinstance 和 type的区别，判断对象的类型还是使用isinstance
class A:
    pass
class B(A):
    pass
print(isinstance(B(),A)) # True
print(isinstance(B(),B)) # True
print(type(B()) is B) # True
print(type(B()) is A) # False

```
### 类变量和实例变量
```python
class A:
    a = 9 # 类变量
    def __init__(self,x,y): # self是类的实例
        self.x = x # 实例变量
        self.y = y # 实例变量
a = A(1,2)
print(a.x,a.y,a.a) # x和y好理解，而a变量是因为在实例调用变量时会先查找实例变量，
                   # 找不到会向上查找类变量
print(A.a) # 可以直接通过类名来找到类变量，但不能找实例变量
A.a = 11
print(A.a,a.a) # 此时均为11
a.a = 10
print(A.a,a.a) # 此时均为A.a = 11,a.a = 10
```
当用实例方法调用类变量并赋值看似时赋值操作，其实质是新建一个实例属性（跟类变量同名），然后在对这个实例属性赋值，随后调用的实际是这个实例属性（因为查找顺序是**先实例属性，随后才是类属性**）


