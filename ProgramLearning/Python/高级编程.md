## 一切皆对象

### python中的函数和类都是对象，属于python的一等公民。
1. 可赋值给变量
2. 可以加入集合中
3. 可以作为函数的返回值
4. 可作为参数传递给函数
```python
# 函数是对象
def ask(name='yzj_func'):
    print(name)
myfunc = ask # 1. 可以赋值给变量
myfunc()
# 类是对象
class Person:
    def __init__(self):
        print('yzj_class')
myclass = Person
myclass()
# 可以加入集合中
objlist = [Person,ask]
for obj in objlist:
    print(obj())
# 作为函数的返回值
def decorator_func():
    print('des start')
    return ask
myask = decorator_func()
myask('hello world')
```
### type,object和class的关系
1. type（类，也是一个对象，继承于object，是type的实例） - 返回一个对象的类型，或者用于生成一个类（我们构建的类都是由type这个类生成的）。
2. object 是所有类继承的一个基类(最顶层基类，默认继承，是type的实例，没有基类)，查看一个类的基类的方法是 classname.\_\_bases\_\_

![](https://github.com/undersunshine/MyArticle/blob/master/Algorithm/images/201810181024.png)

### python中常见的内置类型
1. 对象的三个特征—— 对象的id（利用id(obj)方法可以查看）,对象均有一个类型，对象都有一个值。
常见类型：
```python
None: 全局中仅有一个，唯一一个的对象
数值类型： bool，数值int和float，complex复数类型
迭代类型：可以用for循环进行遍历
序列类型：list，bytes，range，tuple....
映射类型：dict
集合：set，frozenset
上下文管理类型：可以用with语句进行访问
其它....
```


## 魔法函数
在类中以双下划线开头的一些python内置方法，例如__init__，__getitem__等

__str__方法和__repr__方法：
```python
class Company:
    def __init__(self,employee_list):
        self.emplyee = employee_list
    
    def __str__(self): # 用于字符串格式化
        return ','.join(self.emplyee) # print方法打印对象时输出的文本信息

    def __repr__(self): # 在开发模式下调用,直接键入对象名会打印返回文本信息
        return ','.join(self.emplyee)

company = Company(['tom','bob','jack'])
print(company) # 输出 tom,bob,jack
```

## 类和对象深入

### 鸭子类型
几个类提供了相同的方法，执行相似的操作，则这几个类可以归为同一个类型（因此python才分为迭代类型，序列类型等等，在python中称为数据类型）。鸭子类型也是这个概念。然后在一些操作中，例如list的extend方法，其要求传入的类型为可迭代类型，例如a，b，c都是可迭代类型，则都可传入。而静态语言需要具体到特定的类型，例如只能传入a类，b类或c类，这样python的灵活性比较高。而鸭子类型是基于python的魔法函数（通过设置魔法函数以实现不同的特性）实现的。

### 抽象基类 —— abc模块
抽象基类不能实例化，抽象基类的应用场景是在某些情况下需要判断某个对象的类型，或者强制某些子类必须实现某些方法
```python
hasattr(o,attrname); # 判断某个对象是否有某个属性（方法或属性变量） 
isinstance(o,classtype); # 判断某个对象是否是某个类型

import abc
class CacheBase(metaclass=abc.ABCMeta):
    @abc.abstractmethod # 定义为抽象方法，则子类必须实现该方法才能被初始化，否则子类初始化会报错
    def hello(self,k):
        pass
# 等价于
class CacheBase():
    def hello(self,k):
        raise NotImplementedError

# isinstance 和 type的区别，判断对象的类型还是使用isinstance
class A:
    pass
class B(A):
    pass
print(isinstance(B(),A)) # True
print(isinstance(B(),B)) # True
print(type(B()) is B) # True
print(type(B()) is A) # False

```
### 类变量和实例变量
```python
class A:
    a = 9 # 类变量
    def __init__(self,x,y): # self是类的实例
        self.x = x # 实例变量
        self.y = y # 实例变量
a = A(1,2)
print(a.x,a.y,a.a) # x和y好理解，而a变量是因为在实例调用变量时会先查找实例变量，
                   # 找不到会向上查找类变量
print(A.a) # 可以直接通过类名来找到类变量，但不能找实例变量
A.a = 11
print(A.a,a.a) # 此时均为11
a.a = 10
print(A.a,a.a) # 此时均为A.a = 11,a.a = 10
```
当用实例方法调用类变量并赋值看似时赋值操作，其实质是新建一个实例变量（跟类变量同名），然后在对这个实例属性赋值，随后调用的实际是这个实例属性（因为查找顺序是**先实例变量，随后才是类变量**）

#### 类属性和实例属性的查找顺序
深度优先 - 广度优先 - C3算法

C3算法：继承关系存在下，会在本类中查找类属性和实例属性，然后再搜索父类中的类属性和实例属性，且避免了深度优先和广度优先中存在的问题
```python
classname.__mro__ # 可以提出类的继承关系
```

### 静态方法，类方法和对象方法
1. 静态方法 - 参数列表中没有带self或cls，由@staticmethod装饰器修饰，当函数体中不带有类或实例相关的属性时使用，类似于命名空间的概念，即该方法属于该类下的方法，类名可看作是该方法的命名空间，调用该方法是需要带上类名
2. 类方法 - 参数列表中cls，由@classmethod装饰器修饰，当函数体中需要用到类变量或类本身时可定义，cls表示类本身
3. 对象方法 - 在类中定义的普通方法，参数列表中带self参数
综上：使用三种方法根据实际情况而定
```python
class Date:
    def __init__(self,year,month,day):
        self.year = year
        self.month = month
        self.day = day
    def tomorrow(self):
        self.day += 1
    @staticmethod # 静态方法
    def parse_from_str(date_str):
        year,month,day = tuple(date_str.split())
        return Date(int(year),int(month),int(day))
    @classmethod
    def from_string(cls,date_str): # cls是类本身，self是实例对象
        year, month, day = tuple(date_str.split())
        return cls(int(year), int(month), int(day))
    def __str__(self):
        return "{}/{}/{}".format(self.year,self.month,self.day)

if __name__ == "__main__":
    date = Date(2018,12,25)
    date.tomorrow()
    print(date)
    print(date.from_string('2009 12 23'))
    print(date.parse_from_str('2009 12 24'))
```

### 私有属性
在属性名开头加双下划线，使得该属性变成私有属性，只能通过公共方法来实现对该属性的访问。其实现的机制是将该变量名进行转换，从而我们我无法访问该变量（转变为_classname__varname）

### 自省机制
通过一定的机制查询到对象的内部结构，通过__dict__方法实现
```python
class Person:
    name = 'name'
class Student(Person):
    def __init__(self,schoolname):
        self.schoolname = schoolname

if __name__ == '__main__':
    user = Student('123')
    print(user.__dict__) # {'schoolname':'123'} 因为name是属于Person的，因此没有打印出来
    print(Person.__dict__) # 字典结构，类中的一切属性
    user.__dict__['addr'] = 'shanghai'
    print(user.addr) # 打印shanghai，因此可以通过__dict__来添加一个实例的属性或一个类变量
```
也可以用dir(obj)显示对象中的所有属性信息。

### super
super()表示的是父类
```python
class A:
    def __init__(self):
        print('A')
class B(A):
    def __init__(self):
        print('B')
        super().__init__() # 调用了父类（根据__mro__的顺序进行调用）的构造方法
if __name__ == "__main__":
    b = B()
```
### try except finally，with（上下文管理器）
函数中的return语句，如果在finally中存在return语句，则返回finally中的return内容（顺序压栈，最后return的是栈顶内容，因此如果finally有return内容则这个return的内容就是最后一个压入栈顶的元素，因此会被返回）。

with语句的运用
```python
class Sample:
    def __enter__(self):
        print('enter Sample') # 获取资源
        return self 
    def __exit__(self, exc_type, exc_val, exc_tb):
        print('exit Sample') # 释放资源
    def do_something(self):
        print('doing something')

with Sample() as S:
    S.do_something()

# 输出 enter Sample - doing something - exit Sample
```
基于contextlib库实现上下文管理
```python
import contextlib
@contextlib.contextmanager # 修饰一个生成器
def file_open(file_name):
    print('file open ' + file_name) # 在进入上下文后调用
    yield {} # 将函数转换为一个生成器
    print('file end') # 在离开上下文后调用

with file_open('yy.txt') as f:
    print('file process')
```
